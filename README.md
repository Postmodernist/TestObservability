# TestObservability

#### Задание

Пусть есть некий источник данных (repository), интерфейс которого имеет метод Single<MyModel> getMyModel().  И также имеется презентер, который обращается к репозиторию и вызывает метод getMyModel().

Требуется продолжить реактивную цепочку после вызова getMyModel() таким образом, чтобы любые приходящие события (началась загрузка, успешно загружено или произошла ошибка) сразу оправлялись на "рендеринг" во View. Получение терминального onError в цепочке следует избегать.

```
mRepository.getMyModel()
    . ... // TODO: modify/transform stream
    .subscribe(mView::render, throwable -> throw throwable);
```

Реализацией метода getMyModel в целом можно пренебречь - не обязательно делать реальный запрос к какому-то серверу. Достаточно эмуляции долгого ответа и ошибки

Если задание покажется слишком простым, добавить pull-to-refresh таким образом, чтобы предыдущая загрузка данных, если она есть, отменялась и начиналась новая загрузка.
вызов условного mDisposable.dispose() должен быть только 1 раз - в onDestroy() презентера. Использовать dispose() для отмены предыдущей загрузки по pull-to-refresh - нельзя

#### Реализация

View обращается за потоком к ViewModel, которая, в свою очередь, обращается к Repository. Последний имитирует длительную операцию и, в зависимости от аргумента, ошибку при "скачивании" данных.

ViewModel отвечает за преобразование потока в формат, потребляемый View::render и, в случае надобности, за отмену предыдущей незавершенной загрузки при активации новой.

Для удобства тестирования в UI есть две кнопки: одна запускает удачный сценарий скачивания, вторая -- сценарий с ошибкой.
